= Procedures



Procedures, or _functions_ as they are called in some other programming languages, are parts of code that perform a specific task, packaged as a unit.
The benefit of grouping code together like this is that we can "call" these procedures instead of writing all the code over again when we want to do something again.
In some of the previous chapters we looked at the Collatz conjecture in various different scenarios.
By wrapping up the Collatz conjecture logic into a procedure we could have called the same code for all the exercises.

So far we have used many built-in procedures, such as `echo` for printing, `add` for adding elements to a sequence, `inc` to increase the value of an integer, `len` to get the length of a container, etc.
Now we'll see how to create and use our own procedures.

Some of the advantages of using procedures are:

* Reducing code duplication
* Easier to read code as we can name pieces by what they do
* Decomposing a complex task into simpler steps






== Declaring a procedure

Before we can use (call) our procedure, we need to create it and define what it does.

A procedure is declared by using `proc` keyword and the procedure name, followed by the input parameters and their type inside of parentheses, and the last part is a colon and the type of the value returned from a procedure, like this:

[source]
----
proc <name>(<p1>: <type1>, <p2>: <type2>, ...): <returnType> =
----

The body of a procedure is written in the indented block following the declaration.

[source]
.callProcs.nim
----
include::{source-dir}/callProcs.nim[lines=1..8]
----
<1> Declaring procedure called `findMax`, which has two parameters, `x` and `y`, and it returns an `int` type.
<2> To return a value from a procedure, we use `return` keyword.


{nbsp}

[source]
----
proc echoLanguageRating(language: string) =     # <1>
  case language
    of "Nim", "nim", "NIM":
      echo language, " is the best language!"
    else:
      echo language, " might be a second-best language."
----
<1> Procedure `echoLanguageRating` just echoes given name, it doesn't return anything, so the return type is not declared.






== Calling the procedures

After we have declared a procedure, we can call it.
The usual way of calling procedures/functions in many programming languages is to state its name and provide the arguments in the parentheses, like this:

[source]
----
<procName>(<arg1>, <arg2>, ...)
----

The result from calling a procedure can be stored in a variable.

If we want to call our `findMax` procedure from the above example, and save the return value in a variable we can do that with:

[source]
.callProcs.nim
----
include::{source-dir}/callProcs.nim[lines=10..18]
----
<1> The variable `c` is storing the result from the function `findMax` called with the results of first two calls (`findMax(987, 321)`).

[source, output]
----
987
321
987
----

{nbsp}

Nim supports https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax[Uniform Function Call Syntax], which allows a second way of calling the procedures where the first argument is written before the function name, and the rest of the parameters are stated in parentheses:

[source]
----
<arg1>.<procName>(<arg2>, ...)
----

We have used this syntax when we were adding elements to an existing sequence (`<seq>.add(<element>)`), as this makes it more readable and expresses our intent more clearly than writing `add(<seq>, <element>)`.

[source]
.ufcs.nim
----
include::{source-dir}/ufcs.nim[lines=1..14]
----
<1> If multiple parameters are of the same type, we can declare their type in this compact way.

[source, output]
----
true
true
----

This syntax allows for more readable chaining of multiple procedures:

[source]
.ufcs.nim
----
include::{source-dir}/ufcs.nim[lines=16..18]
----
<1> First we add `a` and `b`, then the result of that operation (2 + 3 = 5) is passed as a first parameter to the `multi` procedure, where it is multiplied by `c` (5 * 4 = 20).
<2> First we multiply `c` and `b`, then the result of that operation (4 * 3 = 12) is passed as a first parameter to the `add` procedure, where it is added by `a` (12 + 2 = 14).

[source, output]
----
20
14
----




== Result variable

In Nim, every procedure that returns a value has an implicitly declared and initialized (with a default value) `result` variable.
The procedure will return the value of the `result` when it reaches the end of its indented block.

[source]
.result.nim
----
include::{source-dir}/result.nim[lines=1..9]
----
<1> The return type is `int`. The `result` variable is initialized with the default value for `int` -- `0`.
<2> When the end of the procedure is reached, the value of `result` is returned.

[source, output]
----
33
----

{nbsp}

// TODO: delete/modify this part once the new behaviour for strings and sequences is in the stable version.

WARNING: Beware!
The default value of strings and sequences is https://en.wikipedia.org/wiki/Null_pointer[`nil`], and when we use them as returning types, `result` variable needs to be initialized as an empty string (`""`) or as an empty sequence (`@[]`).

[source]
.result.nim
----
include::{source-dir}/result.nim[lines=11..20]
----
<1> Sequences must be _initialized_. (Try deleting this line and see what happens.) Notice that `var` must _not_ be used, as `result` is already implicitly _declared_.

[source, output]
----
@[1, 43, 57]
----


{nbsp}

Inside of a procedure we can also call other procedures.

[source]
.filterOdds.nim
----
include::{source-dir}/filterOdds.nim[]
----
<1> Initializing the `result` variable as an empty sequence. Because the return value is declared as `seq[int]`, the `result` can only accept integers.
<2> Calling previously declared procedure. Its return type is `bool` and can be used in the if-statement.
<3> Third way of calling procedure. Possible only when the procedure takes one argument.

[source, output]
----
@[6, 9, 0, 3]
@[3]
@[45390, 3219]
----





== Exercises

1. Create a procedure which will greet a person (print "Hello <name>") based on the provided name. Create a sequence of names. Greet each person using the created procedure.

2. Create a procedure `findMax3` which will return the largest of three values.

3. Write a procedure which will test if a given number is a https://en.wikipedia.org/wiki/Prime_number[prime] or not.

4. Points in 2D plane can be represented as `tuple[x, y: float]`. Write a procedure which will receive two points and return a new point which is a sum of those two points (add x's and y's separately).


Test all procedures by calling them with different parameters.
